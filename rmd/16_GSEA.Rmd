---
title: "Functional Analyses"
date: "`r format(Sys.time(), '%d %B, %Y')`"

output:
  bookdown::html_document2:
    number_sections: false
    theme: spacelab
    highlight: monochrome
    code_folding: show
    toc: true
    toc_float: true
    toc_depth: 2
    df_print: paged

params:
  seed:
    label: 'Random seed:'
    value: 8211673
---


# Setup

```{r}
timestamp()
```

```{r}
getwd()
```


```{r}
cbind(params)
```

```{r}
library(tidyverse)
library(enrichR)
library(Seurat)
```

```{r}
set.seed(params$seed)
knitr::opts_chunk$set(echo = TRUE, format = TRUE, out.width = "100%")
```

## Load Data (WrapUp!)

We'll be working with the data from our past notebook ("First steps"), let's quickly re-load and re-process again:

```{r}
# NOTE: This code block will be repeated throughout the course, and it has 5 parameters that are good candidates to be moved to the YAML header(s). If this were an actual research report, we would have probably done this.

pbmc <- Read10X(data.dir = "./datasets/filtered_gene_bc_matrices/hg19/") %>%
  CreateSeuratObject(counts = ., project = "pbmc3k", min.cells = 3, min.features = 200)

pbmc[["percent.mt"]] <- PercentageFeatureSet(pbmc, pattern = "^MT-")

pbmc <- subset(pbmc, subset = nFeature_RNA > 200 & nFeature_RNA < 2500 & percent.mt < 5)

pbmc <- NormalizeData(pbmc, verbose = FALSE)

pbmc <- FindVariableFeatures(pbmc, verbose = FALSE)

pbmc <- ScaleData(pbmc, features = rownames(pbmc), verbose = FALSE)

pbmc <- RunPCA(pbmc, features = VariableFeatures(pbmc), verbose = FALSE)
```

# Gene Set Enrichment Analysis (GSEA)

These methods started with the results obtained from microarrays, and nowadays are usually in use to draw conclusions from the differential expression results after any RNA sequencing experiment (be it single cell or not).

> NOTE: This task in itself could be addressed in a whole course or even a book... as [this one](https://yulab-smu.top/biomedical-knowledge-mining-book/clusterProfiler-dplyr.html). We'll just scratch the surface, and see the most usual approach.

The aim is to draw conclusions as to what's the functional implications that we may be able to derive given a list of genes. To this end, we'd start with such list and then consult databases for the annotations. With this data, we can come up with scores to measure level of association. A gene set is an unordered collection of genes that are functionally related.

**GSEA** (released in 2003 by Broad Institute) aggregates the per gene statistics across genes within a set, therefore making it possible to detect situations where all genes in a predefined set change in a small but coordinated way. This is important since it is likely that many relevant phenotypic differences are manifested by small but consistent changes in a set of genes.

> We need to define the 'sets' of genes that we want to test. Recall the PC Loadings? How about testing if any of our first PCs are enriched in genes that are associated to a common functionality?

The PCA results are ready, let's make a dataframe with their first 9 components; and look at their first 20 rows:

```{r}
pca <- as.data.frame(Loadings(pbmc[["pca"]])[, 1:9])
head(pca, 20)
```

We'd want the top 50 genes from each component, let's just do it with the first component for now. In general, is easier to handle tasks in these modular form, and later expand to whole datasets.

```{r}
gene.set.1 <- arrange(pca, -PC_1) %>%
  head(50) %>%
  rownames()
```


> âŒ¨ðŸ”¥ Exercise:: Let's wrap this into a function that takes three inputs: (1) `seurat_obj`, Seurat object with PCA already run; (2) `pc_number`, an integer representing the desired PC number to use; (3) `gene_total`, the quantity of  'top' gene names to extract; and (4) `anticorrelation`, a Boolean representing that we want to get the top or the bottom genes in the PC. Such function should return a vector name of appropriate length, with the gene names. This has been already been programmed for you, but you'll need to fill-in the three `?` signs.

```{r,eval=FALSE}
myWrap <- function(seurat_obj,
                   pc_number = 1,
                   gene_total = 10,
                   correlation = FALSE) {
  
  pc_number <- paste0("PC_", pc_number)
  
  pca_obj <- ?
  
  pulled_column <- pca_obj[pc_number]
  
  if (?) {
    pulled_column <- arrange(pca_obj)
  } else {
    pulled_column <- arrange(pca_obj,
                             desc(pca_obj[pc_number]))
  }
  
  pulled_column %>%
    ?(gene_total) %>%
    rownames()
}

result <- myWrap(pbmc)
all(result %in% gene.set.1)
```

Equipped with this function, we are now able to take a look into the genes corresponding to the variability correlated (positively or negatively) to each of the first principal components.

## Gene Ontology

[GO Terms](http://www.geneontology.org/) are semantic representations in a curated database that defines concepts/classes used to describe gene function, and relationships between these concepts. GO terms are organized in a directed acyclic graph, where edges between terms represent parent-child relationship. It classifies functions along three aspects:

- MF: Molecular Function, molecular activities of gene products
- CC: Cellular Compartment, where gene products are active
- BP: Biological Processes, pathways and larger processes made up of the activities of multiple gene products

## enrichR

The package is already loaded. But we need to connect to the databases that we'll be using. There are more than 200 databases available, you can get a data frame with details of these using `listEnrichrDbs()`.

```{r}
dbs <- c(
  "GO_Biological_Process_2021",
  "GO_Cellular_Component_2021",
  "GO_Molecular_Function_2021"
)
```


```{r}
result.1 <- enrichr(gene.set.1, dbs)
```

Currently, `result.1` is a list object (analogous to a python dictionary), with three dataframes as elements, each corresponding to one of the databases. The `enrichR` library provides functions to explore these. For example:

```{r}
plotEnrich(result.1[[1]], showTerms = 20, numChar = 40, y = "Count", orderBy = "P.value")
```

The title is not so informative, right? And maybe there are a couple more of customiztions we'd like to do.

Instead of copying and pasting, and customizing each of the calls to `plotEnrich()` is easier to encapsulate functionality into function wrappers that are then copied over each time you want to call your customized plot or table, for example:

```{r}
retrieve_clean_title <- function(dbs, N) {
  # https://regexr.com/
  gsub("^.{3}(.*).{5}$", "\\1", dbs[N])
}

filter_enrichment_results <- function(enriched, N) {
  enriched[[dbs[N]]] %>%
    filter(
      Adjusted.P.value < 5e-2,
      Odds.Ratio != 1
    ) %>%
    arrange(-Combined.Score)
}

enrichment_as_print_df <- function(enriched, N) {
  df <- data.frame(filter_enrichment_results(enriched, N)[
    ,
    c("Term", "Overlap", "Odds.Ratio", "Adjusted.P.value", "Combined.Score")
  ])
  row.names(df) <- df$Term
  df$Term <- NULL
  df
}

my_plot_enrich <- function(enriched, dbs, N) {
  df <- filter_enrichment_results(enriched, N)
  if (dim(df)[1] > 0) {
    plotEnrich(df,
      showTerms = 25, numChar = 75,
      title = retrieve_clean_title(dbs, N)
    )
  } else {
    print("No pathway was enriched.")
  }
}

# Notes:
# - Only showing enrichments with odds ratio &ne; `1` & p-value < `0.05` (fdr).
# - The combined score is computed as `ln(p)*z`, and is used to arrange values in the tables.
# - Tables are complete full list, and plots only show the top 25 pathways with biggest odds ratio.
# - Color scale follows p-value (fdr).
```

> âŒ¨ðŸ”¥ Exercise:: Write specifications for each of the functions, what are their inputs types? What are their outputs types? Are all functions always returning the same output types?

### Plots

Then you only need to repeat the call to wrappers that do all the 'heavy' lifting...

#### Biological Process

```{r}
my_plot_enrich(result.1, dbs, 1)
```

```{r}
enrichment_as_print_df(result.1, 1) %>% DT::datatable()
```

#### Cellular Component

```{r}
my_plot_enrich(result.1, dbs, 2)
```

```{r}
enrichment_as_print_df(result.1, 2) %>% DT::datatable()
```

#### Molecular Function

```{r}
my_plot_enrich(result.1, dbs, 3)
```

```{r}
enrichment_as_print_df(result.1, 3) %>% DT::datatable()
```

# End

> âŒ¨ðŸ”¥ Exercise:: Explore all first 9 PCs using `my_plot_enrich` and `enrichment_as_print_df`.
