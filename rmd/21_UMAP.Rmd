---
title: "Manifolds?!"
date: "`r format(Sys.time(), '%d %B, %Y')`"

output:
  bookdown::html_document2:
    number_sections: false
    theme: spacelab
    highlight: monochrome
    code_folding: show
    toc: true
    toc_float: true
    toc_depth: 2
    df_print: paged

params:
  Nthreads:
    label: 'Number of Threads:'
    value: 8
    input: slider
    min: 4
    max: 96
  Nmemgb:
    label: 'Gigabytes of Memory per Thread:'
    value: 8
    input: slider
    min: 4
    max: 16
  fork:
    label: 'Fork processes (not GUI)'
    value: FALSE
    input: checkbox
  seed:
    label: 'Random seed:'
    value: 8211673
  dimensionality:
    label: 'Dimensionality of single-cell dataset:'
    value: 10
  cluster_resolution:
    label: 'Parameter for clustering algorithm:'
    value: 0.5
---


# Setup

```{r}
timestamp()
```

```{r}
getwd()
```


```{r}
cbind(params)
```

```{r}
library(tidyverse)
library(Seurat)
```

```{r}
set.seed(params$seed)
knitr::opts_chunk$set(echo = TRUE, format = TRUE, out.width = "100%")

options(
  parallelly.fork.enable = params$fork,
  future.globals.maxSize = params$Nmemgb * 1024^2 * 1000
)

plan("multicore", workers = params$Nthreads)

myFlappy <- function(x, ...) {
  future.apply::future_lapply(x, ..., future.seed = TRUE)
}
```

## Load Data

We'll be working with the data from Day 1 ("First steps"), let's quickly re-load and re-process again:

```{r}
pbmc <- Read10X(data.dir = "./datasets/filtered_gene_bc_matrices/hg19/") %>%
  CreateSeuratObject(counts = ., project = "pbmc3k", min.cells = 3, min.features = 200)

pbmc[["percent.mt"]] <- PercentageFeatureSet(pbmc, pattern = "^MT-")

pbmc <- subset(pbmc, subset = nFeature_RNA > 200 & nFeature_RNA < 2500 & percent.mt < 5)

pbmc <- NormalizeData(pbmc, verbose = FALSE)

pbmc <- FindVariableFeatures(pbmc, verbose = FALSE)

pbmc <- ScaleData(pbmc, features = rownames(pbmc), verbose = FALSE)

pbmc <- RunPCA(pbmc, features = VariableFeatures(pbmc), verbose = FALSE)

pbmc <- FindNeighbors(pbmc, dims = seq_len(params$dimensionality), verbose = FALSE)

pbmc <- FindClusters(pbmc, resolution = params$cluster_resolution, verbose = FALSE)
```

# Manifolds

This abstract concept comes from either Geometry or Physics. Basically, **a manifold is every "space" with this property: locally, it looks like a Euclidean plane**. For example, if you draw a triangle on the surface of a ball, the sum of the angles is not 180. So, it's not euclidean. Yet, if the triangle is small, and uses a small surface, it would behave approximately as euclidean. This portion of space would be a manifold.

## The Problem:

How can we visualize all our points (cells) across multiple dimensions (principal components)? Can we reduce 10 PCs into a 2D Cartesian plane? Turns out we can, and there are two solutions that were developed. In these, the concept of manifold is key, in the sense that on our end result, **the distance between points has lower error when these points are close enough.** This suits our case, since we want to plot clusters of cells that are from a same cell type.

### t-distributed stochastic neighbor embedding (t-SNE)

**The t-SNE algorithm** uses the Gaussian probability density function to calculate how likely a point (cell) will pick another one as its neighbor, and repeats this step for all points. In the low dimension space, cells are rearranged according to these distances, creating the t-SNE plot. While the original algorithm uses the Euclidean distance between objects as the base of its similarity metric, this can be changed.

t-SNE has been used for visualization in a wide range of applications. For further details, see some of these resources:

- [Google TechTalk](https://www.youtube.com/watch?v=RJVL80Gg3lA&list=UUtXKDgv1AVoG88PLl8nGXmw) (Duration 55 min.)
- [StatQuest!](https://www.youtube.com/watch?v=NEaUSP4YerM) video (Durantion 10 min.)
- [2019 paper](https://www.nature.com/articles/s41467-019-13056-x) summarizing the challenges for scRNA-seq data.
- [original paper](https://jmlr.csail.mit.edu/papers/volume9/vandermaaten08a/vandermaaten08a.pdf) from 2008.

### Uniform Manifold Approximation and Projection (UMAP)

UMAP, in a more clever way, **creates a fuzzy graph that accurately reflects the topology (a.k.a shape) of the true high dimensional graph, calculates the weight for edges of this graph, then builds the low dimensional graph mimicking the fuzzy graph.** Since its development came 10 years later, it adds a bunch of advantages.

For further details, see the [original paper](https://arxiv.org/pdf/1802.03426) from 2018 or [this amazing website](https://pair-code.github.io/understanding-umap/) from Google's People+AI Research (PAIR) initiative.

### Comparison

- Key parameters for t-SNE and UMAP are the **perplexity** and **number of neighbors**, respectively.
- It's notable that t-SNE projections vary widely from run to run, with different pieces of the higher-dimensional data projected to different locations. While UMAP is also a stochastic algorithm, it's striking how similar the resulting projections are from run to run and with different parameters. This is due, again, to UMAP's increased emphasis on global structure in comparison to t-SNE.
- t-SNE and UMAP have the same principle and workflow: create a high dimensional graph, then reconstruct it in a lower dimensional space while retaining the structure.
- t-SNE moves the high dimensional graph to a lower dimensional space points by points. UMAP compresses that graph.
- UMAP is more time-saving due to the clever solution in creating a rough estimation of the high dimensional graph instead of measuring every point.
- UMAP gives a better balance between local versus global structure, thus overall gives a more accurate presentation of the global structure. This will come in handy in trajectory analysis.

> Two-point Take Away:
> 
> - UMAP is often better at preserving global structure in the final projection. To compete, t-SNE would require a high 'perplexity' parameter, so the computatin time shoots.
>
> - Dimensionality reduction techniques are not perfect. By necessity, we're distorting the data to fit it into lower dimensions -- and UMAP is no exception.

### Common Pitfalls

- Cluster sizes in a UMAP plot mean nothing
- Distances between clusters might not mean anything
- You may need more than one plot, changing its hyperparameters.

# Plotting High-Dimensional Data

Seurat offers several non-linear dimensional reduction techniques, such as tSNE and UMAP, to visualize and explore these datasets. **The goal of these algorithms is** to learn the underlying manifold of the data in order **to place similar cells together in low-dimensional space**. Cells within the graph-based clusters determined above should co-localize on these dimension reduction plots. As input to the UMAP and tSNE, we use the dimensionality of our dataset (e.g. same PCs as input to clustering).

Due to the mathematical difference, each method has different parameters to control this. For t-SNE, itâ€™s the perplexity. For UMAP, itâ€™s the number of neighbors. The two parameters are what we should take care of when optimizing our data visualization. 

```{r}
pbmc <- RunTSNE(pbmc, dims = seq_len(params$dimensionality))
```

```{r}
pbmc <- RunUMAP(pbmc, dims = seq_len(params$dimensionality))
```

```{r}
DimPlot(pbmc, reduction = "umap") + NoLegend() |
  DimPlot(pbmc, reduction = "tsne") + NoLegend()
```

> âŒ¨ðŸ”¥ Exercise: Would decreasing the number of PCs fed onto the clustering algorithm change our visualization? Would you say the results are 'better'?

# BREAK

## Annotation

Fortunately in the case of this dataset, we can use canonical markers to easily match the clusters to known cell types. Given that this dataset was downloaded, we already know its labels; so we can simply use a hardcoded vector to assign the correct identities.

Needless to say, normally you would check the expression of some signature genes and do a query. **This analysis will be shown another day of this course.**

```{r, eval=FALSE}
new.cluster.ids <- c(
  "Naive CD4 T", "CD14+ Mono", "Memory CD4 T", "B", "CD8 T", "FCGR3A+ Mono",
  "NK", "DC", "Platelet"
)
names(new.cluster.ids) <- levels(pbmc)
pbmc <- RenameIdents(pbmc, new.cluster.ids)

DimPlot(pbmc, reduction = "umap", label = TRUE, pt.size = 0.5) + NoLegend()
```

