---
title: "Manifolds?!"
date: "`r format(Sys.time(), '%d %B, %Y')`"

output:
  bookdown::html_document2:
    theme: spacelab
    highlight: monochrome
    code_folding: hide
    toc: true
    toc_float: true
    toc_depth: 2
    df_print: paged

params:
  Nthreads:
    label: 'Number of Threads:'
    value: 8
    input: slider
    min: 4
    max: 96
  Nmemgb:
    label: 'Gigabytes of Memory per Thread:'
    value: 8
    input: slider
    min: 4
    max: 16
  fork:
    label: 'Fork processes (not GUI)'
    value: FALSE
    input: checkbox
  seed:
    label: 'Random seed:'
    value: 8211673
  dimensionality:
    label: 'Dimensionality of single-cell dataset:'
    value: 10
  cluster_resolution:
    label: 'Parameter for clustering algorithm:'
    value: 0.5
---


# Setup

```{r}
timestamp()
```

```{r}
getwd()
```


```{r}
cbind(params)
```

```{r}
my_load_namespaces <- function(packagesToLoad=c(), coreLibraries=c()) {
  installed_pkgs <- installed.packages()
  if (! "BiocManager" %in% installed_pkgs) install.packages("BiocManager")
  lapply(c(coreLibraries, packagesToLoad),
         function(x) if (! x %in% installed_pkgs) BiocManager::install(x, ask = FALSE))
  lapply(packagesToLoad, function(pkg) {
    suppressPackageStartupMessages(require(pkg, character.only = TRUE))
  })
  TRUE
}

my_load_namespaces(
  packagesToLoad = c("openxlsx", "readr", "magrittr", "dplyr", "RColorBrewer", "ggplot2", "patchwork", "Seurat"),
  coreLibraries = c("knitr", "rmarkdown", "formatR", "DT", "reticulate", "sessioninfo", "limma", "DESeq2", "enrichR", "future", "uwot", "future.apply", "metap", "shiny", "SingleCellExperiment", "remotes", "bookdown", "SeuratData")
)
```

```{r}
if (interactive()) stopifnot(suppressMessages(BiocManager::valid()))

set.seed(params$seed)
knitr::opts_chunk$set(echo = TRUE, format = TRUE)

options(parallelly.fork.enable = params$fork,
        future.globals.maxSize = params$Nmemgb * 1024^2 * 1000)

plan("multicore", workers = params$Nthreads)

myFlappy <- function(x, ...) {
  future.apply::future_lapply(x, ..., future.seed = TRUE)
}
```

## Load Data

We'll be working with the data from Day 1, `14_FirstSteps.Rmd`, let's quickly re-load and re-process again:

```{r}
pbmc <- Read10X(data.dir = "./datasets/filtered_gene_bc_matrices/hg19/") %>%
  CreateSeuratObject(counts = ., project = "pbmc3k", min.cells = 3, min.features = 200)

pbmc[["percent.mt"]] <- PercentageFeatureSet(pbmc, pattern = "^MT-")

pbmc <- subset(pbmc, subset = nFeature_RNA > 200 & nFeature_RNA < 2500 & percent.mt < 5)

pbmc <- NormalizeData(pbmc, verbose = FALSE)

pbmc <- FindVariableFeatures(pbmc, verbose = FALSE)

pbmc <- ScaleData(pbmc, features = rownames(pbmc), verbose = FALSE)

pbmc <- RunPCA(pbmc, features = VariableFeatures(pbmc), verbose = FALSE)

pbmc <- FindNeighbors(pbmc, dims = seq_len(params$dimensionality), verbose = FALSE)

pbmc <- FindClusters(pbmc, resolution = params$cluster_resolution, verbose = FALSE)
```

# Manifolds

This abstract concept comes from either Geometry or Physics. Basically, **a manifold is every "space" with this property: locally, it looks like a Euclidean plane**. For example, if you draw a triangle on the surface of a ball, the sum of the angles is not 180. So, it's not euclidean. Yet, if the triangle is small, and uses a small surface, it would behave approximately as euclidean. This portion of space would be a manifold.

## The Problem:

How can we visualize all our points (cells) across multiple dimensions (principal components)? Can we reduce 10 PCs into a 2D cartesian plane? Turns out we can, and there are two solutions that were developed in recent years. In these, the concept of manifold is key, in the sense that on our end result, **the distance between points has lower error when these points are close enough.** This suits our case, since we want to plot clusters of cells that are from a same cell type.

### t-distributed stochastic neighbor embedding (t-SNE)

**The t-SNE algorithm that uses the Gaussian probability density function to calculate how likely a point (cell) will pick another one as its neighbor, and repeats this step for all points.** In the low dimension space, cells are rearranged according to these distances, creating the t-SNE plot. While the original algorithm uses the Euclidean distance between objects as the base of its similarity metric, this can be changed.

t-SNE has been used for visualization in a wide range of applications. For further details, see the [original paper](https://jmlr.csail.mit.edu/papers/volume9/vandermaaten08a/vandermaaten08a.pdf) from 2008.

### Uniform Manifold Approximation and Projection (UMAP)

UMAP, in a more clever way, **creates a fuzzy graph that accurately reflects the topology (a.k.a shape) of the true high dimensional graph, calculates the weight for edges of this graph, then builds the low dimensional graph mimicking the fuzzy graph.** Since its development came 10 years later, it adds a bunch of advantages.

For further details, see the [original paper](https://arxiv.org/pdf/1802.03426) from 2018.

### Take Away

- t-SNE and UMAP are both non-linear, graph-based methods for dimensionality reduction in scRNA-seq analysis.
- t-SNE and UMAP are both for data visualization. They are not meant to tell you about clustering or variation as much as methods like PCA do. 
- t-SNE and UMAP have the same principle and workflow: create a high dimensional graph, then reconstruct it in a lower dimensional space while retaining the structure.
- t-SNE moves the high dimensional graph to a lower dimensional space points by points. UMAP compresses that graph.
- Key parameters for t-SNE and UMAP are the perplexity and number of neighbors, respectively. 
- **UMAP is more time-saving due to the clever solution in creating a rough estimation of the high dimensional graph instead of measuring every point.**
- **UMAP gives a better balance between local versus global structure, thus overall gives a more accurate presentation of the global structure.** This will come in handy in trajectory analysis. 

# Plotting High-Dimensional Data

Seurat offers several non-linear dimensional reduction techniques, such as tSNE and UMAP, to visualize and explore these datasets. **The goal of these algorithms is** to learn the underlying manifold of the data in order **to place similar cells together in low-dimensional space**. Cells within the graph-based clusters determined above should co-localize on these dimension reduction plots. As input to the UMAP and tSNE, we use the dimensionality of our dataset (e.g. same PCs as input to clustering).

Due to the mathematical difference, each method has different parameters to control this. For t-SNE, it’s the perplexity. For UMAP, it’s the number of neighbors. The two parameters are what we should take care of when optimizing our data visualization. 

```{r}
pbmc <- RunTSNE(pbmc, dims = seq_len(params$dimensionality))
```

```{r}
pbmc <- RunUMAP(pbmc, dims = seq_len(params$dimensionality))
```

```{r}
DimPlot(pbmc, reduction = "umap") + NoLegend() |
  DimPlot(pbmc, reduction = "tsne") + NoLegend()
```

POLL: Would decreasing the number of PCs fed onto the clustering algorithm change our visualization? Would it then be better, worse, or neutral?

## Annotation

Fortunately in the case of this dataset, we can use canonical markers to easily match the clusters to known cell types. Given that this dataset was downloaded, we already know its labels; so we can simply use a hardcoded vector to assign the correct identities.

Needless to say, normally you would check the expression of some signature genes and do a query. **This analysis will be shown another day of this course.**

```{r}
new.cluster.ids <- c("Naive CD4 T", "CD14+ Mono", "Memory CD4 T", "B", "CD8 T", "FCGR3A+ Mono",
    "NK", "DC", "Platelet")
names(new.cluster.ids) <- levels(pbmc)
pbmc <- RenameIdents(pbmc, new.cluster.ids)
```

```{r}
DimPlot(pbmc, reduction = "umap", label = TRUE, pt.size = 0.5) + NoLegend()
```

